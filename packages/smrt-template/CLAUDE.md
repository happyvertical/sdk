# @have/smrt-template: Triple-Purpose Microservice Foundation Package

## Purpose and Responsibilities

The `@have/smrt-template` package is a comprehensive template for building sophisticated microservices with the SMRT framework. It demonstrates how to create a single codebase that can be consumed in three different ways:

- **Standalone Application**: Complete, independent web application with full UI and functionality
- **Module Federation Provider**: Runtime component sharing across applications
- **NPM Package Library**: Traditional build-time imports for maximum optimization

This package serves as both a working example and a foundation for building production-ready microservices that leverage auto-generation from `@smrt()` decorated classes. It automatically generates REST APIs, MCP tools, TypeScript clients, UI components, and type definitions from simple class definitions.

**Expert Agent Expertise**: When working with this package, always proactively check the latest documentation for template engines (Handlebars, EJS), code generation tools (Hygen, Plop), module federation (@originjs/vite-plugin-federation), and Svelte 5 runes, as they frequently add new features, scaffolding patterns, and federation capabilities that can enhance template development and microservice architecture.

## Key APIs

### Triple-Purpose Consumption Patterns

#### 1. NPM Package Library Usage

```typescript
import { Product, ProductCard, productStore } from '@have/smrt-template';
import { createClient, setupRoutes } from '@have/smrt-template';
import type { ProductData } from '@have/smrt-template';

// Use model classes
const product = new Product({
  name: 'Example Product',
  price: 29.99,
  inStock: true
});

// Use generated client
const client = createClient('/api/v1');
const products = await client.products.list();

// Use Svelte components (in a Svelte app)
import ProductCard from '@have/smrt-template/components';
```

#### 2. Module Federation Consumer

```svelte
<script>
  // Runtime imports from federation
  import ProductCatalog from 'productService/ProductCatalog';
  import ProductCard from 'productService/ProductCard';
  import UserProfile from 'userService/UserProfile';
</script>

<!-- Compose application from multiple federated services -->
<div class="dashboard">
  <UserProfile userId={currentUser.id} />
  <ProductCatalog readonly={true} />
</div>
```

#### 3. Standalone Application

```bash
# Development
npm run dev:standalone
# Standalone app: http://localhost:3001

# Production deployment
docker run -p 3001:3001 product-service
```

### SMRT Model Definition

```typescript
import { BaseObject } from '@have/smrt';

@smrt({
  api: {
    exclude: ['delete'] // Don't generate DELETE endpoint
  },
  mcp: {
    include: ['list', 'get', 'create'] // Only expose these as AI tools
  },
  cli: true // Enable CLI commands
})
export class Product extends BaseObject {
  name: string = '';
  description?: string;
  price: number = 0;
  inStock: boolean = true;
  category: string = '';
  tags: string[] = [];

  async calculateDiscount(percentage: number): Promise<number> {
    return this.price * (percentage / 100);
  }

  async updateInventory(quantity: number): Promise<void> {
    this.inStock = quantity > 0;
  }

  static async findByCategory(categoryId: string): Promise<Product[]> {
    // Implementation auto-generated by SMRT
    return [];
  }
}
```

This automatically generates:
- `GET /api/v1/products` - List products
- `POST /api/v1/products` - Create product
- `GET /api/v1/products/:id` - Get product
- `PUT /api/v1/products/:id` - Update product
- MCP tools for AI integration
- TypeScript client methods
- Full type definitions

### Svelte 5 Runes State Management

```typescript
export class ProductStoreClass {
  private data = $state<ProductStore>({
    items: [],
    loading: false,
    error: null
  });

  private api = createClient('/api/v1');

  // Reactive getters
  get items() { return this.data.items; }
  get inStockCount() {
    return this.data.items.filter(p => p.inStock).length;
  }

  // Actions with auto-generated API integration
  async loadProducts() {
    this.data.loading = true;
    try {
      const response = await this.api.products.list();
      this.data.items = response.data;
    } catch (err) {
      this.data.error = err.message;
    } finally {
      this.data.loading = false;
    }
  }

  async createProduct(productData: Partial<ProductData>) {
    const response = await this.api.products.create(productData);
    if (response.data) {
      this.data.items.push(response.data);
    }
    return response;
  }
}

export const productStore = new ProductStoreClass();
```

### Auto-Generated Virtual Modules

```typescript
// Import auto-generated modules from SMRT Vite plugin
import setupRoutes from '@smrt/routes';      // Auto-generated REST routes
import createClient from '@smrt/client';     // Auto-generated TypeScript client
import createMCPServer from '@smrt/mcp';     // Auto-generated MCP tools
import { manifest } from '@smrt/manifest';   // Object metadata
import type * from '@smrt/types';            // Auto-generated TypeScript types

// Setup server with auto-generated routes
const app = express();
app.use('/api/v1', setupRoutes());

// Use auto-generated client
const client = createClient('/api/v1');
const products = await client.products.list();

// Start MCP server for AI integration
const mcpServer = createMCPServer();
mcpServer.start();
```

### Module Federation Configuration

```typescript
// Federation Expose Configuration
export const exposeConfig = {
  components: {
    './ProductCard': './src/lib/components/ProductCard.svelte',
    './ProductForm': './src/lib/components/ProductForm.svelte'
  },
  features: {
    './ProductCatalog': './src/lib/features/ProductCatalog.svelte',
    './CategoryManager': './src/lib/features/CategoryManager.svelte'
  },
  applications: {
    './ProductsPage': './src/app/pages/ProductsPage.svelte'
  },
  logic: {
    './Product': './src/lib/models/Product.ts',
    './ProductStore': './src/lib/stores/product-store.svelte.ts'
  }
};
```

### Multi-Mode Development

```bash
# Development (all modes simultaneously)
npm run dev
# Standalone: http://localhost:3001
# Federation: http://localhost:3002

# Individual mode development
npm run dev:standalone   # Standalone app only
npm run dev:federation   # Federation server only
npm run dev:library      # Library build with watch

# Production builds
npm run build            # All build variants
npm run build:lib        # NPM package
npm run build:app        # Standalone application
npm run build:federation # Module federation
```

## Dependencies

The package has the following dependencies:

### Internal Dependencies (workspace)
- `@have/smrt`: Core SMRT framework for auto-generation and base classes

### External Dependencies
- `svelte`: Modern reactive UI framework with runes-based state management
- `vite`: Build tool with multi-mode configuration support
- `@sveltejs/vite-plugin-svelte`: Svelte integration for Vite
- `@originjs/vite-plugin-federation`: Module federation support for runtime component sharing
- `concurrently`: Run multiple development servers simultaneously
- `vitest`: Testing framework

### Development Dependencies
- `@types/node`: TypeScript definitions for Node.js
- Standard TypeScript and build tooling

## Development Guidelines

### Template Architecture Patterns

- **Triple-Purpose Design**: Single codebase supporting multiple consumption patterns
- **Auto-Generation First**: Leverage SMRT decorators to minimize boilerplate
- **Modular Federation**: Design components for runtime sharing
- **Library-First**: Ensure all components work as standalone NPM packages

### SMRT Model Best Practices

- Use meaningful decorator configurations to control API generation
- Implement business logic methods alongside data properties
- Follow TypeScript naming conventions (PascalCase for classes, camelCase for properties)
- Include proper JSDoc comments for auto-generated documentation

### Component Development

- Build Svelte 5 components using runes for reactive state
- Design components for both standalone and federated usage
- Keep federation exports focused and minimal
- Use TypeScript interfaces for all props and events

### State Management

- Use Svelte 5 runes for reactive state management
- Integrate auto-generated API clients in store classes
- Implement derived state using getters
- Handle loading states and errors consistently

### Testing

The package includes comprehensive testing setup:

```bash
bun test        # Run tests once
bun test:watch  # Run tests in watch mode
```

Test patterns:
- Unit tests for SMRT models and business logic
- Integration tests for auto-generated APIs
- Component tests for UI components
- End-to-end tests for complete user flows

### Building and Development

Build the package with:

```bash
bun run build       # Build all modes
bun run build:lib   # Library build only
bun run build:app   # Standalone app only
bun run build:federation # Federation build only
```

Development workflow:
```bash
bun run dev         # Start all development servers
bun run dev:all     # Same as dev
npm run clean       # Clean all build artifacts
```

### Best Practices

#### Template Development
- Design for reusability across multiple consumption patterns
- Use consistent export patterns for library consumers
- Implement proper TypeScript declarations for all exports
- Document component props and usage patterns

#### Federation Architecture
- Keep exposed components focused and single-purpose
- Minimize external dependencies in federated modules
- Use proper error boundaries in federated components
- Test federation integration with consumer applications

#### Code Generation
- Follow consistent patterns in SMRT model definitions
- Use meaningful decorator configurations
- Implement proper validation in generated APIs
- Test auto-generated code thoroughly

#### Performance Optimization
- Implement code splitting for standalone applications
- Use lazy loading for large federation modules
- Optimize build outputs for different consumption patterns
- Monitor bundle sizes across all build modes

## Documentation Links

Always reference the latest documentation when planning template and microservice solutions, as these libraries frequently add new features, federation patterns, and optimization techniques:

### Core Template and Code Generation Libraries
- **Handlebars**: https://handlebarsjs.com/ (Template engine for code generation)
  - Check for new helper functions and compilation optimizations
  
- **Hygen**: https://github.com/jondot/hygen (Code generator and template scaffolding)
  - Review for new template patterns and generation workflows
  
- **Plop**: https://plopjs.com/ (Micro-generator framework for teams)
  - Monitor for new action types and generator patterns

### Module Federation and Micro-frontends
- **@originjs/vite-plugin-federation**: https://github.com/originjs/vite-plugin-federation
  - Essential for module federation configuration and runtime sharing
  - Check for new federation features and optimization techniques
  
- **Module Federation Guide**: https://module-federation.github.io/
  - Comprehensive guide to micro-frontend architecture patterns
  - Review for new federation strategies and best practices

### Svelte 5 and Reactive State
- **Svelte 5 Runes**: https://svelte.dev/docs/svelte/what-are-runes
  - Latest reactive state management patterns with runes
  - Monitor for new rune types and reactive patterns
  
- **SvelteKit**: https://kit.svelte.dev/docs/introduction
  - Full-stack Svelte framework for complex applications
  - Check for new adapter types and deployment patterns

### Build Tools and Optimization
- **Vite**: https://vitejs.dev/guide/ | https://vitejs.dev/config/
  - Modern build tool with exceptional development experience
  - Review for new plugin ecosystem and build optimizations
  
- **Vitest**: https://vitest.dev/guide/ (Testing framework built on Vite)
  - Check for new testing patterns and integration techniques

### Expert Agent Instructions

When working with @have/smrt-template:

1. **Always check latest documentation** before implementing solutions using WebFetch tool
2. **Stay current with federation patterns** - module federation evolves rapidly
3. **Review new Svelte 5 features** that could improve component development
4. **Check for breaking changes** in build tools and federation plugins
5. **Look for new code generation techniques** and template patterns
6. **Monitor micro-frontend architecture trends** and best practices

Example proactive research workflow:
```typescript
// Before implementing federation solution, check latest docs
await WebFetch.get('https://github.com/originjs/vite-plugin-federation/releases');
await WebFetch.get('https://svelte.dev/docs/svelte/what-are-runes');
// Then implement with current best practices
```

### Template Scaffolding Resources
- **Yeoman**: https://yeoman.io/ (Web scaffolding tool for modern web apps)
- **Create-Svelte**: https://github.com/sveltejs/kit/tree/master/packages/create-svelte
- **Nx**: https://nx.dev/ (Smart, fast and extensible build system)
- **Lerna**: https://lerna.js.org/ (Tool for managing JavaScript projects with multiple packages)

This package provides the foundation for building sophisticated, auto-generating microservices that can be consumed as standalone applications, federated modules, or traditional NPM packages - all from a single, maintainable codebase.